#[macro_use]
extern crate diesel;
extern crate dotenvy;

use diesel::prelude::*;
use diesel::result::Error;
use rocket::serde::{json::Json, Deserialize, Serialize};
use rocket::State;
use shuttle_diesel::ShuttleDiesel;

// Diesel schema definition (auto-generated by Diesel)
mod schema {
    diesel::table! {
        todos (id) {
            id -> Int4,
            note -> Text,
        }
    }

    diesel::table! {
        salons (id) {
            id -> Int4,
            name -> Text,
        }
    }
}

use schema::{salons, todos};

// Diesel model definitions
#[derive(Queryable, Serialize, Insertable)]
#[diesel(table_name = todos)]
pub struct Todo {
    pub id: i32,
    pub note: String,
}

#[derive(Queryable, Serialize, Insertable)]
#[diesel(table_name = salons)]
pub struct Salon {
    pub id: i32,
    pub name: String,
}

#[derive(Deserialize)]
pub struct NewTodo {
    pub note: String,
}

#[derive(Deserialize)]
pub struct NewSalon {
    pub name: String,
}

// Database connection wrapper
pub struct DbConn(diesel::PgConnection);

#[shuttle_runtime::main]
async fn main() -> shuttle_rocket::ShuttleRocket {
    // Set up database connection
    let database_url = std::env::var("DATABASE_URL").expect("DATABASE_URL must be set");
    let conn = PgConnection::establish(&database_url).expect("Error connecting to database");

    // Run migrations
    embedded_migrations::run(&conn).expect("Error running migrations");

    let state = MyState { conn };
    let rocket = rocket::build()
        .mount("/todo", routes![retrieve, add])
        .mount("/salons", routes![salons::create, salons::fetch_id])
        .manage(state);

    Ok(rocket.into())
}

// State management
struct MyState {
    conn: PgConnection,
}

// Todo routes
#[post("/", data = "<data>")]
pub async fn add(
    data: Json<NewTodo>,
    state: &State<MyState>,
) -> Result<Json<Todo>, BadRequest<String>> {
    use schema::todos::dsl::*;

    let new_todo = NewTodo {
        note: data.note.clone(),
    };

    let todo = diesel::insert_into(todos)
        .values(&new_todo)
        .get_result(&mut state.conn)
        .map_err(|e| BadRequest(e.to_string()))?;

    Ok(Json(todo))
}

#[get("/<id>")]
pub async fn retrieve(id: i32, state: &State<MyState>) -> Result<Json<Todo>, BadRequest<String>> {
    use schema::todos::dsl::*;

    let todo = todos
        .find(id)
        .first(&mut state.conn)
        .map_err(|e| BadRequest(e.to_string()))?;

    Ok(Json(todo))
}

// Salon routes module
mod salons {
    use super::*;

    #[post("/", data = "<data>")]
    pub async fn create(
        data: Json<NewSalon>,
        state: &State<MyState>,
    ) -> Result<Json<Salon>, BadRequest<String>> {
        use schema::salons::dsl::*;

        let new_salon = NewSalon {
            name: data.name.clone(),
        };

        let salon = diesel::insert_into(salons)
            .values(&new_salon)
            .get_result(&mut state.conn)
            .map_err(|e| BadRequest(e.to_string()))?;

        Ok(Json(salon))
    }

    #[get("/<id>")]
    pub async fn fetch_id(
        id: i32,
        state: &State<MyState>,
    ) -> Result<Json<Salon>, BadRequest<String>> {
        use schema::salons::dsl::*;

        let salon = salons
            .find(id)
            .first(&mut state.conn)
            .map_err(|e| BadRequest(e.to_string()))?;

        Ok(Json(salon))
    }
}
